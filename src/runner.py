#!/usr/bin/env python3
"""
RSI + Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Ïä§Ï∫òÌïë ÏûêÎèôÎß§Îß§ Î©îÏù∏ Ïã§ÌñâÍ∏∞

Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌïòÍ≥† Ï†ÑÎûµÏùÑ Ïã§ÌñâÌïòÏó¨ ÏûêÎèôÎß§Îß§Î•º ÏàòÌñâÌï©ÎãàÎã§.
DRYRUN Î™®ÎìúÏóêÏÑúÎäî Ïã§Ï†ú Ï£ºÎ¨∏ ÏóÜÏù¥ ÏãúÎÆ¨Î†àÏù¥ÏÖòÎßå ÏàòÌñâÌï©ÎãàÎã§.

ÏÇ¨Ïö©Î≤ï:
    python src/runner.py --market KRW-BTC --krw 10000 --mode DRYRUN
    python src/runner.py --market KRW-ETH --krw 5000 --mode LIVE
"""

import argparse
import time
import os
import signal
import sys
from typing import List, Dict, Optional, Any
from datetime import datetime

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ ÎîîÎ†âÌÜ†Î¶¨Î•º Python Í≤ΩÎ°úÏóê Ï∂îÍ∞Ä
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from src.upbit_api import upbit_api
from src.trader import trader
from src.strategy.hybrid_scalper import get_hybrid_strategy_instance, HybridScalperConfig
from src.state_manager import StateManager
from src.risk_manager import RiskManager
from src.logger import logger

class TradingRunner:
    """ÏûêÎèôÎß§Îß§ Ïã§ÌñâÍ∏∞"""
    
    def __init__(self, market: str, krw_amount: float, trading_mode: str = "DRYRUN"):
        self.market = market
        self.krw_amount = krw_amount
        self.trading_mode = trading_mode.upper()
        
        # Ïª¥Ìè¨ÎÑåÌä∏ Ï¥àÍ∏∞Ìôî (ÌïòÏù¥Î∏åÎ¶¨Îìú Ïä§Ï∫òÌçº, ÏΩîÏù∏Î≥Ñ ÎèÖÎ¶ΩÏ†ÅÏù∏ Ïù∏Ïä§ÌÑ¥Ïä§)
        self.strategy = get_hybrid_strategy_instance(self.market)
        self.state_manager = StateManager(f".state/trade_state_{market.replace('-', '_').lower()}.json")
        self.risk_manager = RiskManager()
        
        # ÏÉÅÌÉú Î°úÎìú
        self.state = self.state_manager.load_state()
        
        # ÏÑ§Ï†ï
        self.loop_interval = 1.0  # 1Ï¥à Ï£ºÍ∏∞ (API Î†àÏù¥Ìä∏ Î¶¨Î∞ã Í≥†Î†§)
        self.candle_count = 80    # Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ Í∞úÏàò (SMA60 Í≥†Î†§ÌïòÏó¨ Ï¶ùÍ∞Ä)
        self.order_cooldown = 5   # Ï£ºÎ¨∏ ÌõÑ Ïø®Îã§Ïö¥ (5Ï¥àÎ°ú Îã®Ï∂ï)
        self.last_order_time = 0
        
        # Ïã§Ìñâ ÏÉÅÌÉú
        self.running = False
        self.error_count = 0
        self.max_errors = 10
        
        # ÏïàÏ†ÑÏû•Ïπò
        if self.trading_mode not in ["DRYRUN", "LIVE"]:
            raise ValueError("Trading mode must be 'DRYRUN' or 'LIVE'")
        
        logger.info(f"Trading Runner initialized: {market}, {krw_amount} KRW, Mode: {trading_mode}")
    
    def get_candles(self) -> Optional[List[Dict[str, Any]]]:
        """Î∂ÑÎ¥â Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        try:
            # 1Î∂ÑÎ¥â Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            candles = upbit_api.get_candles_minutes(self.market, unit=1, count=self.candle_count)
            
            if not candles:
                logger.error("Failed to fetch candle data")
                return None
            
            # ÏóÖÎπÑÌä∏ APIÎäî ÏµúÏã† Îç∞Ïù¥ÌÑ∞Í∞Ä Ï≤´ Î≤àÏß∏Ïóê Ïò§ÎØÄÎ°ú Ïó≠ÏàúÏúºÎ°ú Ï†ïÎ†¨ (Í≥ºÍ±∞ -> ÌòÑÏû¨)
            candles.reverse()
            
            logger.debug(f"Fetched {len(candles)} candles for {self.market}")
            return candles
        
        except Exception as e:
            logger.error(f"Error fetching candles: {e}")
            return None
    
    def execute_buy_order(self, signal_meta: Dict) -> bool:
        """Îß§Ïàò Ï£ºÎ¨∏ Ïã§Ìñâ"""
        try:
            # Î¶¨Ïä§ÌÅ¨ ÏÇ¨Ï†Ñ Í≤ÄÏ¶ù
            krw_balance, _ = trader.get_balance('KRW')
            current_positions = 1 if self.state.get('has_position') else 0
            
            allowed, reason = self.risk_manager.check_pre_trade(
                market=self.market,
                krw_amount=self.krw_amount,
                current_positions=current_positions,
                current_balance=krw_balance
            )
            
            if not allowed:
                logger.warning(f"Buy order rejected by risk manager: {reason}")
                return False
            
            # Î†àÏù¥Ìä∏ Î¶¨Î∞ã ÎåÄÍ∏∞
            self.risk_manager.wait_for_rate_limit()
            
            if self.trading_mode == "DRYRUN":
                # ÎìúÎùºÏù¥Îü∞ Î™®Îìú: ÏãúÎÆ¨Î†àÏù¥ÏÖò
                current_price = signal_meta.get('current_price', 0)
                simulated_volume = self.krw_amount / current_price if current_price > 0 else 0
                
                # ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ÑÎûµ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Îã§Ï§ë ÏßÑÏûÖ Í∏∞Îä• Ï†úÍ±∞Îê®)
                # if hasattr(self.strategy, 'update_multi_entry'):
                #     self.strategy.update_multi_entry(current_price, simulated_volume)
                
                # ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                self.state = self.state_manager.enter_position(
                    self.state, self.market, current_price, simulated_volume, "DRYRUN_BUY"
                )
                
                entry_strategy = getattr(self.strategy, 'entry_strategy', 'unknown')
                logger.info(f"[DRYRUN] BUY {self.market}: {self.krw_amount:,} KRW at {current_price:,} KRW (Vol: {simulated_volume:.6f}) (Strategy: {entry_strategy})")
                return True
            
            else:
                # Ïã§Ï†ú Í±∞Îûò Î™®Îìú
                result = trader.market_buy(self.market, self.krw_amount, confirm=False)

                if result:
                    # üîç Ï≤¥Í≤∞ Ï†ïÎ≥¥ ÌôïÏù∏ Îã®Í≥Ñ Ï∂îÍ∞Ä
                    order_uuid = result.get('uuid')
                    executed_volume = 0
                    executed_price = 0

                    if order_uuid:
                        # Ï≤¥Í≤∞ ÌôïÏù∏ ÏöîÏ≤≠ (APIÏóêÏÑú Ï≤¥Í≤∞ ÏôÑÎ£å Ï†ïÎ≥¥ Î∞õÏïÑÏò§Í∏∞)
                        time.sleep(0.5)  # ÏÑúÎ≤Ñ Î∞òÏòÅ ÎåÄÍ∏∞
                        order_info = trader.get_order(order_uuid)
                        if order_info and 'trades' in order_info:
                            filled_trades = order_info['trades']
                            if filled_trades:
                                executed_volume = sum(float(t['volume']) for t in filled_trades)
                                total_price = sum(float(t['price']) * float(t['volume']) for t in filled_trades)
                                executed_price = total_price / executed_volume if executed_volume > 0 else 0

                    # ‚ö†Ô∏è Ï≤¥Í≤∞ Ï†ïÎ≥¥ ÏóÜÏùÑ Í≤ΩÏö∞ ÎåÄÎπÑ
                    if executed_volume <= 0 or executed_price <= 0:
                        logger.warning(f"[Safety Fix] No filled volume info for {self.market}. Using fallback price={signal_meta.get('current_price', 0)}")
                        executed_volume = self.krw_amount / max(signal_meta.get('current_price', 1), 1)
                        executed_price = signal_meta.get('current_price', 0)

                    # ÏÉÅÌÉú Ï†ÄÏû•
                    self.state = self.state_manager.enter_position(
                        self.state, self.market, executed_price, executed_volume, result.get('uuid')
                    )

                    entry_strategy = getattr(self.strategy, 'entry_strategy', 'unknown')
                    logger.info(f"[LIVE] BUY executed: {result['uuid']} (Vol={executed_volume:.6f}, Price={executed_price}) (Strategy: {entry_strategy})")
                    self.last_order_time = time.time()
                    return True

                else:
                    logger.error("Buy order failed")
                    return False
        
        except Exception as e:
            logger.error(f"Error executing buy order: {e}")
            return False
    
    def execute_sell_order(self, signal_meta: Dict) -> bool:
        """Îß§ÎèÑ Ï£ºÎ¨∏ Ïã§Ìñâ"""
        try:
            position_info = self.state_manager.get_position_info(self.state)
            if not position_info:
                logger.warning("No position to sell")
                return False
            
            volume = position_info['entry_volume']
            if volume is None or volume <= 0:
                market = self.market
                logger.error(f"[Safety Stop] Invalid sell volume={volume} for {market}. Skipping sell order.")
                return False

            # Î†àÏù¥Ìä∏ Î¶¨Î∞ã ÎåÄÍ∏∞
            self.risk_manager.wait_for_rate_limit()
            
            if self.trading_mode == "DRYRUN":
                # ÎìúÎùºÏù¥Îü∞ Î™®Îìú: ÏãúÎÆ¨Î†àÏù¥ÏÖò
                current_price = signal_meta.get('current_price', 0)
                exit_reason = signal_meta.get('reason', 'unknown')
                entry_price = position_info.get('entry_price', 0)
                
                # ÏàòÏùµ Í≥ÑÏÇ∞ Î∞è Î¶¨Ïä§ÌÅ¨ Îß§ÎãàÏ†Ä ÏóÖÎç∞Ïù¥Ìä∏
                if entry_price > 0:
                    profit_krw = (current_price - entry_price) * volume
                    is_loss = profit_krw < 0
                    self.risk_manager.update_trade_result(profit_krw, is_loss)
                
                self.state = self.state_manager.exit_position(
                    self.state, current_price, exit_reason, "DRYRUN_SELL"
                )
                
                # ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ÑÎûµ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
                if hasattr(self.strategy, '_reset_strategy_state'):
                    self.strategy._reset_strategy_state()
                
                logger.info(f"[DRYRUN] SELL {self.market}: {volume:.6f} at {current_price:,} KRW (Reason: {exit_reason})")
                return True
            
            else:
                # Ïã§Ï†ú Í±∞Îûò Î™®Îìú
                result = trader.market_sell(self.market, volume, confirm=False)
                
                if result:
                    # Ï£ºÎ¨∏ ÏÑ±Í≥µ
                    executed_price = float(result.get('price', 0)) if result.get('price') else signal_meta.get('current_price', 0)
                    exit_reason = signal_meta.get('reason', 'manual')
                    entry_price = position_info.get('entry_price', 0)
                    
                    # ÏàòÏùµ Í≥ÑÏÇ∞ Î∞è Î¶¨Ïä§ÌÅ¨ Îß§ÎãàÏ†Ä ÏóÖÎç∞Ïù¥Ìä∏
                    if entry_price > 0:
                        profit_krw = (executed_price - entry_price) * volume
                        is_loss = profit_krw < 0
                        self.risk_manager.update_trade_result(profit_krw, is_loss)
                    
                    self.state = self.state_manager.exit_position(
                        self.state, executed_price, exit_reason, result.get('uuid')
                    )
                    
                    # ÌïòÏù¥Î∏åÎ¶¨Îìú Ï†ÑÎûµ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
                    if hasattr(self.strategy, '_reset_strategy_state'):
                        self.strategy._reset_strategy_state()
                    
                    logger.info(f"[LIVE] SELL executed: {result['uuid']}")
                    self.last_order_time = time.time()
                    return True
                else:
                    logger.error("Sell order failed")
                    return False
        
        except Exception as e:
            logger.error(f"Error executing sell order: {e}")
            return False
    
    def process_signal(self, signal: Dict[str, Any]) -> bool:
        """ÏãúÍ∑∏ÎÑê Ï≤òÎ¶¨"""
        action = signal.get('action', 'HOLD')
        meta = signal.get('meta', {})
        
        # Ïø®Îã§Ïö¥ Ï≤¥ÌÅ¨
        if time.time() - self.last_order_time < self.order_cooldown:
            if action in ['BUY', 'SELL']:
                logger.debug(f"Order cooldown active, skipping {action}")
                return False
        
        if action == 'BUY':
            if self.state.get('has_position'):
                logger.warning("Already have position, ignoring BUY signal")
                return False
            
            return self.execute_buy_order(meta)
        
        elif action == 'SELL':
            if not self.state.get('has_position'):
                logger.warning("No position to sell, ignoring SELL signal")
                return False
            
            return self.execute_sell_order(meta)
        
        else:  # HOLD
            # ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÏÉÅÌÉú Î°úÍπÖ (ÏÉÅÏÑ∏Ìïú Í≤ΩÏö∞ÏóêÎßå)
            if self.state.get('has_position'):
                reason = meta.get('reason', 'unknown')
                if reason == 'holding_position':
                    profit_rate = meta.get('profit_rate', 0)
                    hold_time = meta.get('hold_time', 0)
                    entry_strategy = meta.get('entry_strategy', 'unknown')
                    logger.debug(f"Holding position: {profit_rate*100:.2f}%, {hold_time:.0f}s, Strategy: {entry_strategy}")
            
            return True
    
    def run_loop(self):
        """Î©îÏù∏ Ïã§Ìñâ Î£®ÌîÑ"""
        logger.info(f"Starting trading loop for {self.market} (Mode: {self.trading_mode})")
        
        try:
            while self.running:
                loop_start = time.time()
                
                try:
                    # 0. ÏùëÍ∏â Ï†ïÏßÄ ÌôïÏù∏
                    if self.risk_manager.emergency_stop:
                        logger.critical("Emergency stop activated, halting trading")
                        break
                    
                    # 1. Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
                    candles = self.get_candles()
                    if not candles:
                        logger.warning("No candle data, skipping iteration")
                        time.sleep(self.loop_interval)
                        continue
                    
                    # 2. Ìö°Î≥¥ ÏãúÏû• ÌïÑÌÑ∞ (ÏßÑÏûÖ ÏãúÏóêÎßå)
                    if not self.state.get('has_position'):
                        is_ranging, ranging_meta = self.risk_manager.is_ranging_market(candles)
                        if not is_ranging:
                            logger.debug(f"Not ranging market, skipping: {ranging_meta.get('reason', 'unknown')}")
                            time.sleep(self.loop_interval)
                            continue
                    
                    # 3. ÌòÑÏû¨ Ìè¨ÏßÄÏÖò ÏÉÅÌÉú ÌôïÏù∏
                    position_state = self.state if self.state.get('has_position') else None
                    
                    # 4. Ï†ÑÎûµ ÏãúÍ∑∏ÎÑê ÏÉùÏÑ±
                    signal = self.strategy.generate_signal(candles, position_state)
                    
                    # 5. ÏãúÍ∑∏ÎÑê Ï≤òÎ¶¨
                    success = self.process_signal(signal)
                    
                    # 6. ÏÉÅÌÉú Ï†ÄÏû•
                    if success and signal.get('action') in ['BUY', 'SELL']:
                        self.state_manager.save_state(self.state)
                    
                    # 7. ÏóêÎü¨ Ïπ¥Ïö¥Ìä∏ Î¶¨ÏÖã
                    self.error_count = 0
                    
                    # 8. ÌÜµÍ≥Ñ Ï∂úÎ†• (Ï£ºÍ∏∞Ï†Å)
                    if int(time.time()) % 60 == 0:  # 1Î∂ÑÎßàÎã§
                        self.print_status()
                
                except Exception as e:
                    self.error_count += 1
                    logger.error(f"Error in main loop ({self.error_count}/{self.max_errors}): {e}")
                    
                    # Î†àÏù¥Ìä∏ Î¶¨Î∞ã Ï≤òÎ¶¨
                    should_retry, wait_time = self.risk_manager.handle_rate_limit(exception=e)
                    if should_retry:
                        logger.info(f"Rate limit/network error, waiting {wait_time:.1f}s")
                        time.sleep(wait_time)
                        continue
                    
                    if self.error_count >= self.max_errors:
                        logger.error("Too many errors, stopping")
                        break
                    
                    # Í∏∞Î≥∏ Î∞±Ïò§ÌîÑ ÏßÄÏó∞
                    backoff_time = min(0.5 + (self.error_count * 0.1), 2.0)
                    time.sleep(backoff_time)
                
                # 7. Î£®ÌîÑ Í∞ÑÍ≤© Ï°∞Ï†à
                elapsed = time.time() - loop_start
                sleep_time = max(0, self.loop_interval - elapsed)
                if sleep_time > 0:
                    time.sleep(sleep_time)
        
        except KeyboardInterrupt:
            logger.info("Interrupted by user")
        except Exception as e:
            logger.error(f"Fatal error in main loop: {e}")
        finally:
            self.cleanup()
    
    def print_status(self):
        """ÌòÑÏû¨ ÏÉÅÌÉú Ï∂úÎ†•"""
        stats = self.state_manager.get_trading_stats(self.state)
        position = self.state_manager.get_position_info(self.state)
        risk_status = self.risk_manager.get_risk_status()
        
        logger.info("=" * 50)
        logger.info(f"Market: {self.market} | Mode: {self.trading_mode}")
        logger.info(f"Total Trades: {stats['total_trades']} | Win Rate: {stats['win_rate']:.1f}%")
        logger.info(f"Total Profit: {stats['total_profit']:,.0f} KRW")
        
        # Î¶¨Ïä§ÌÅ¨ ÏÉÅÌÉú Ï†ïÎ≥¥
        logger.info(f"Risk Status: Emergency Stop: {risk_status['emergency_stop']}, Consecutive Losses: {risk_status['consecutive_losses']}")
        logger.info(f"Daily Loss: {risk_status['daily_stats']['total_loss']:,.0f} KRW")
        
        if position:
            profit_rate = ((time.time() - position['entry_time']) / position['entry_price'] - 1) * 100 if position['entry_price'] > 0 else 0
            logger.info(f"Position: {position['entry_volume']:.6f} at {position['entry_price']:,.0f} KRW")
            logger.info(f"Hold Time: {position['hold_time']:.0f}s")
        else:
            logger.info("Position: None")
        
        logger.info("=" * 50)
    
    def start(self):
        """Ïã§Ìñâ ÏãúÏûë"""
        self.running = True
        
        # ÏãúÍ∑∏ÎÑê Ìï∏Îì§Îü¨ Îì±Î°ù
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        
        # Ï¥àÍ∏∞ ÏÉÅÌÉú Î∞±ÏóÖ
        self.state_manager.backup_state()
        
        # Î©îÏù∏ Î£®ÌîÑ Ïã§Ìñâ
        self.run_loop()
    
    def stop(self):
        """Ïã§Ìñâ Ï§ëÏßÄ"""
        logger.info("Stopping trading runner...")
        self.running = False
    
    def cleanup(self):
        """Ï†ïÎ¶¨ ÏûëÏóÖ"""
        logger.info("Cleaning up...")
        
        # ÏµúÏ¢Ö ÏÉÅÌÉú Ï†ÄÏû•
        self.state_manager.save_state(self.state)
        
        # ÏµúÏ¢Ö ÌÜµÍ≥Ñ Ï∂úÎ†•
        self.print_status()
        
        logger.info("Trading runner stopped")
    
    def _signal_handler(self, signum, frame):
        """ÏãúÍ∑∏ÎÑê Ìï∏Îì§Îü¨"""
        logger.info(f"Received signal {signum}")
        self.stop()

def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    parser = argparse.ArgumentParser(description="RSI + Bollinger Band Scalping Trading Bot")
    parser.add_argument("--market", type=str, required=True, help="Trading market (e.g., KRW-BTC)")
    parser.add_argument("--krw", type=float, required=True, help="KRW amount per trade")
    parser.add_argument("--mode", type=str, default="DRYRUN", choices=["DRYRUN", "LIVE"], help="Trading mode")
    
    args = parser.parse_args()
    
    # ÌôòÍ≤ΩÎ≥ÄÏàòÏóêÏÑú Î™®Îìú Ïû¨Ï†ïÏùò Í∞ÄÎä•
    trading_mode = os.getenv("TRADING_MODE", args.mode).upper()
    
    # ÏïàÏ†Ñ ÌôïÏù∏
    if trading_mode == "LIVE":
        auto_confirm = os.getenv("AUTO_CONFIRM_LIVE", "false").lower() == "true"
        
        print("‚ö†Ô∏è  WARNING: You are about to start LIVE trading!")
        print(f"Market: {args.market}")
        print(f"Amount: {args.krw:,} KRW per trade")
        print("\nThis will use real money. Are you sure?")
        
        if auto_confirm:
            print("AUTO_CONFIRM_LIVE=true, proceeding automatically...")
            confirm = "YES"
        else:
            confirm = input("Type 'YES' to continue: ").strip()
        
        if confirm != "YES":
            print("Aborted.")
            return
    
    try:
        # Ìä∏Î†àÏù¥Îî© Îü¨ÎÑà Ï¥àÍ∏∞Ìôî Î∞è Ïã§Ìñâ
        runner = TradingRunner(args.market, args.krw, trading_mode)
        runner.start()
    
    except Exception as e:
        logger.error(f"Failed to start trading runner: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()